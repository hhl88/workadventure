{"version":3,"sources":["webpack://workadventurefront/./src/Phaser/Shaders/OutlinePipeline.ts","webpack://workadventurefront/./src/Phaser/Items/ActionableItem.ts","webpack://workadventurefront/./src/Phaser/Items/Computer/computer.ts"],"names":["OutlinePipeline","Phaser","Renderer","WebGL","Pipelines","MultiPipeline","game","super","fragShader","KEY","ActionableItem","id","sprite","eventHandler","activationRadius","onActivateCallback","isSelectable","callbacks","Map","this","activationRadiusSquared","x","y","distanceSquared","pipeline","eventName","state","parameters","emitActionableEvent","fire","callback","callbacksArray","get","undefined","Array","set","push","Sprite","isComputerState","withProperties","status","preload","loader","atlas","create","scene","anims","key","frames","frame","frameRate","repeat","factory","object","initState","Error","computer","add","existing","play","item","emit","on"],"mappings":"6KAAO,MAAMA,UAAwBC,EAAOC,SAASC,MAAMC,UAAUC,cAQjE,YAAYC,GAERC,MAAM,CACFD,KAAMA,EACNE,WAAY,w8CATG,EAAAC,IAAM,UCO1B,MAAMC,EAKT,YAA2BC,EAAoBC,EAAwBC,EAAiCC,EAAkCC,GAA/G,KAAAJ,KAAoB,KAAAC,SAAwB,KAAAC,eAAiC,KAAAC,mBAAkC,KAAAC,qBAHlI,KAAAC,cAAwB,EACxB,KAAAC,UAA+C,IAAIC,IAGvDC,KAAKC,wBAA0BN,EAAmBA,EAG/C,QACH,OAAOK,KAAKR,GAOT,mBAAmBU,EAAWC,GACjC,MAAMC,GAAmBF,EAAIF,KAAKP,OAAOS,IAAIA,EAAIF,KAAKP,OAAOS,IAAMC,EAAIH,KAAKP,OAAOU,IAAIA,EAAIH,KAAKP,OAAOU,GACvG,OAAIC,EAAkBJ,KAAKC,wBAChBG,EAEA,KAOR,aACCJ,KAAKH,eAGTG,KAAKH,cAAe,EAChBG,KAAKP,OAAOY,UAUb,gBACEL,KAAKH,eAGVG,KAAKH,cAAe,GAQjB,WACHG,KAAKJ,mBAAmBI,MAGrB,KAAKM,EAAmBC,EAAgBC,EAAsB,MACjER,KAAKN,aAAae,oBAAoBT,KAAKR,GAAIc,EAAWC,EAAOC,GAEjER,KAAKU,KAAKJ,EAAWC,EAAOC,GAGzB,GAAGF,EAAmBK,GACzB,IAAIC,EAAiDZ,KAAKF,UAAUe,IAAIP,QACjDQ,IAAnBF,IACAA,EAAiB,IAAIG,MACrBf,KAAKF,UAAUkB,IAAIV,EAAWM,IAElCA,EAAeK,KAAKN,GAGjB,KAAKL,EAAmBC,EAAgBC,GAC3C,MAAMI,EAAiBZ,KAAKF,UAAUe,IAAIP,GAC1C,QAAuBQ,IAAnBF,EAGJ,IAAK,MAAMD,KAAYC,EACnBD,EAASJ,EAAOC,I,cCzFrBU,EAAS,qBAOhB,MAAMC,GACF,IAAI,eAAiBC,eAAe,CAChCC,OAAQ,aACTR,MAGP,IAAIN,EAAuB,CACvB,OAAU,OAGd,SACIe,QAAUC,IACNA,EAAOC,MAAM,WAAY,yCAA0C,kDAEvEC,OAASC,IACLA,EAAMC,MAAMF,OAAO,CACfG,IAAK,eACLC,OAAQ,CACJ,CACID,IAAK,WACLE,MAAO,iBAGfC,UAAW,GACXC,QAAS,IAEbN,EAAMC,MAAMF,OAAO,CACfG,IAAK,eACLC,OAAQ,CACG,CACID,IAAK,WACLE,MAAO,gBAEX,CACIF,IAAK,WACLE,MAAO,iBAGtBC,UAAW,EACXC,QAAS,KAGjBC,QAAS,CAACP,EAAkBQ,EAAyBC,KACjD,QAAkBrB,IAAdqB,EAAyB,CACzB,IAAKhB,EAAgBgB,GACjB,MAAM,IAAIC,MAAM,8CAEpB7B,EAAQ4B,EAIZ,MAAME,EAAW,IAAInB,EAAOQ,EAAOQ,EAAOhC,EAAGgC,EAAO/B,EAAG,YACvDuB,EAAMY,IAAIC,SAASF,GACE,OAAjB9B,EAAMc,QACNgB,EAASV,MAAMa,KAAK,gBAGxB,MAAMC,EAAO,IAAIlD,EAAe2C,EAAO1C,GAAI6C,EAAUX,EAAO,IAAKe,IACxC,QAAjBlC,EAAMc,QACNd,EAAMc,OAAS,KACfoB,EAAKC,KAAK,UAAWnC,KAErBA,EAAMc,OAAS,MACfoB,EAAKC,KAAK,WAAYnC,OAU9B,OAPAkC,EAAKE,GAAG,WAAW,KACfN,EAASV,MAAMa,KAAK,mBAExBC,EAAKE,GAAG,YAAY,KAChBN,EAASV,MAAMa,KAAK,mBAGjBC","file":"454.js","sourcesContent":["export class OutlinePipeline extends Phaser.Renderer.WebGL.Pipelines.MultiPipeline {\n\n    // the unique id of this pipeline\n    public static readonly KEY = 'Outline';\n\n    /**\n     * @param {Phaser.Game} game - the controller of the game instance\n     */\n    constructor(game: Phaser.Game)\n    {\n        super({\n            game: game,\n            fragShader: `\n        precision mediump float;\n\n        uniform sampler2D uMainSampler;\n        uniform vec2 uTextureSize;\n\n        varying vec2 outTexCoord;\n        varying float outTintEffect;\n        varying vec4 outTint;\n\n        void main(void) \n        {\n          vec4 texture = texture2D(uMainSampler, outTexCoord);\n          vec4 texel = vec4(outTint.rgb * outTint.a, outTint.a);\n          vec4 color = texture;\n\n          if (outTintEffect == 0.0)\n          {\n            color = texture * texel;\n          }\n          else if (outTintEffect == 1.0)\n          {\n            color.rgb = mix(texture.rgb, outTint.rgb * outTint.a, texture.a);\n            color.a = texture.a * texel.a;\n          }\n          else if (outTintEffect == 2.0)\n          {\n            color = texel;\n          }\n\n          vec2 onePixel = vec2(1.0, 1.0) / uTextureSize;\n          float upAlpha = texture2D(uMainSampler, outTexCoord + vec2(0.0, onePixel.y)).a;\n          float leftAlpha = texture2D(uMainSampler, outTexCoord + vec2(-onePixel.x, 0.0)).a;\n          float downAlpha = texture2D(uMainSampler, outTexCoord + vec2(0.0, -onePixel.y)).a;\n          float rightAlpha = texture2D(uMainSampler, outTexCoord + vec2(onePixel.x, 0.0)).a;\n\n          if (texture.a == 0.0 && max(max(upAlpha, downAlpha), max(leftAlpha, rightAlpha)) == 1.0) \n          {\n            color = vec4(1.0, 1.0, 0.0, 1.0);\n          }\n\n          gl_FragColor = color;\n        }\n      `\n        });\n    }\n}\n","/**\n * An actionable item represents an in-game object that can be activated using the space-bar.\n * It has coordinates and an \"activation radius\"\n */\nimport Sprite = Phaser.GameObjects.Sprite;\nimport {OutlinePipeline} from \"../Shaders/OutlinePipeline\";\nimport type {GameScene} from \"../Game/GameScene\";\n\ntype EventCallback = (state: unknown, parameters: unknown) => void;\n\nexport class ActionableItem {\n    private readonly activationRadiusSquared : number;\n    private isSelectable: boolean = false;\n    private callbacks: Map<string, Array<EventCallback>> = new Map<string, Array<EventCallback>>();\n\n    public constructor(private id: number, private sprite: Sprite, private eventHandler: GameScene, private activationRadius: number, private onActivateCallback: (item: ActionableItem) => void) {\n        this.activationRadiusSquared = activationRadius * activationRadius;\n    }\n\n    public getId(): number {\n        return this.id;\n    }\n\n    /**\n     * Returns the square of the distance to the object center IF we are in item action range\n     * OR null if we are out of range.\n     */\n    public actionableDistance(x: number, y: number): number|null {\n        const distanceSquared = (x - this.sprite.x)*(x - this.sprite.x) + (y - this.sprite.y)*(y - this.sprite.y);\n        if (distanceSquared < this.activationRadiusSquared) {\n            return distanceSquared;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Show the outline of the sprite.\n     */\n    public selectable(): void {\n        if (this.isSelectable) {\n            return;\n        }\n        this.isSelectable = true;\n        if (this.sprite.pipeline) {\n            // Commented out to try to fix MacOS issue\n            /*this.sprite.setPipeline(OutlinePipeline.KEY);\n            this.sprite.pipeline.set2f('uTextureSize', this.sprite.texture.getSourceImage().width, this.sprite.texture.getSourceImage().height);*/\n        }\n    }\n\n    /**\n     * Hide the outline of the sprite\n     */\n    public notSelectable(): void {\n        if (!this.isSelectable) {\n            return;\n        }\n        this.isSelectable = false;\n        // Commented out to try to fix MacOS issue\n        //this.sprite.resetPipeline();\n    }\n\n    /**\n     * Triggered when the \"space\" key is pressed and the object is in range of being activated.\n     */\n    public activate(): void {\n        this.onActivateCallback(this);\n    }\n\n    public emit(eventName: string, state: unknown, parameters: unknown = null): void {\n        this.eventHandler.emitActionableEvent(this.id, eventName, state, parameters);\n        // Also, execute the action locally.\n        this.fire(eventName, state, parameters);\n    }\n\n    public on(eventName: string, callback: EventCallback): void {\n        let callbacksArray: Array<EventCallback>|undefined = this.callbacks.get(eventName);\n        if (callbacksArray === undefined) {\n            callbacksArray = new Array<EventCallback>();\n            this.callbacks.set(eventName, callbacksArray);\n        }\n        callbacksArray.push(callback);\n    }\n\n    public fire(eventName: string, state: unknown, parameters: unknown): void {\n        const callbacksArray = this.callbacks.get(eventName);\n        if (callbacksArray === undefined) {\n            return;\n        }\n        for (const callback of callbacksArray) {\n            callback(state, parameters);\n        }\n    }\n}\n","import * as Phaser from 'phaser';\nimport {Scene} from \"phaser\";\nimport Sprite = Phaser.GameObjects.Sprite;\nimport type {ITiledMapObject} from \"../../Map/ITiledMap\";\nimport type {ItemFactoryInterface} from \"../ItemFactoryInterface\";\nimport type {GameScene} from \"../../Game/GameScene\";\nimport {ActionableItem} from \"../ActionableItem\";\nimport * as tg from \"generic-type-guard\";\n\nconst isComputerState =\n    new tg.IsInterface().withProperties({\n        status: tg.isString,\n    }).get();\ntype ComputerState = tg.GuardedType<typeof isComputerState>;\n\nlet state: ComputerState = {\n    'status': 'off'\n};\n\nexport default {\n    preload: (loader: Phaser.Loader.LoaderPlugin): void => {\n        loader.atlas('computer', '/resources/items/computer/computer.png', '/resources/items/computer/computer_atlas.json');\n    },\n    create: (scene: GameScene): void => {\n        scene.anims.create({\n            key: 'computer_off',\n            frames: [\n                {\n                    key: 'computer',\n                    frame: 'computer_off'\n                }\n            ],\n            frameRate: 10,\n            repeat: -1\n        });\n        scene.anims.create({\n            key: 'computer_run',\n            frames: [\n                       {\n                           key: 'computer',\n                           frame: 'computer_on1'\n                       },\n                       {\n                           key: 'computer',\n                           frame: 'computer_on2'\n                       }\n                       ],\n            frameRate: 5,\n            repeat: -1\n        });\n    },\n    factory: (scene: GameScene, object: ITiledMapObject, initState: unknown): ActionableItem => {\n        if (initState !== undefined) {\n            if (!isComputerState(initState)) {\n                throw new Error('Invalid state received for computer object');\n            }\n            state = initState;\n        }\n\n        // Idée: ESSAYER WebPack? https://paultavares.wordpress.com/2018/07/02/webpack-how-to-generate-an-es-module-bundle/\n        const computer = new Sprite(scene, object.x, object.y, 'computer');\n        scene.add.existing(computer);\n        if (state.status === 'on') {\n            computer.anims.play('computer_run');\n        }\n\n        const item = new ActionableItem(object.id, computer, scene, 32, (item: ActionableItem) => {\n            if (state.status === 'off') {\n                state.status = 'on';\n                item.emit('TURN_ON', state);\n            } else {\n                state.status = 'off';\n                item.emit('TURN_OFF', state);\n            }\n        });\n        item.on('TURN_ON', () => {\n            computer.anims.play('computer_run');\n        });\n        item.on('TURN_OFF', () => {\n            computer.anims.play('computer_off');\n        });\n\n        return item;\n        //scene.add.sprite(object.x, object.y, 'computer');\n    }\n} as ItemFactoryInterface;\n"],"sourceRoot":""}